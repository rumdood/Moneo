using System.Collections.Immutable;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis;
using System.Text;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Moneo.Chat.Generators;

[Generator]
public class UserRequestFactoryGenerator : ISourceGenerator
{
    private static class AttributeKeys
    {
        public const string CommandKey = "CommandKey";
        public const string UserCommandAttribute = "UserCommandAttribute";
        public const string UserCommandArgumentAttribute = "UserCommandArgument";
        public const string UserCommandHelpText = "HelpDescription";
    }
    
    private const string Lookup = "_lookup";
    
    public void Initialize(GeneratorInitializationContext context)
    {
        // No initialization required
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // Debugger.Launch();
        var userRequestClasses = GetUserRequests(context);

        foreach (var request in userRequestClasses)
        {
            var source = GenerateCommandKeyProperties(request);
            context.AddSource($"{request.Name}WithCommandKey", SourceText.From(source, Encoding.UTF8));
        }
        
        // Generate the factory class code
        var sourceCode = GenerateFactoryClass(userRequestClasses);

        // Add the generated code to the compilation
        context.AddSource("UserRequestFactory", SourceText.From(sourceCode, Encoding.UTF8));
        
        var helpResponseFactorySource = GenerateHelpResponseFactoryClass(userRequestClasses);
        context.AddSource("HelpResponseFactory", SourceText.From(helpResponseFactorySource, Encoding.UTF8));
    }

    private static string GenerateHelpResponseFactoryClass(ImmutableArray<INamedTypeSymbol> userRequests)
    {
        var namespaces = userRequests.Select(u => u.ContainingNamespace.ToDisplayString()).ToImmutableHashSet();

        var codeBuilder = new StringBuilder("// Generated By Source Generator\n\n");

        foreach (var ns in namespaces.OrderBy(k => k))
        {
            codeBuilder.Append("using ");
            codeBuilder.Append(ns);
            codeBuilder.AppendLine(";");
        }

        var defaultHelpText = new StringBuilder();
        defaultHelpText.AppendLine("Available Commands");
        defaultHelpText.AppendLine("------------------");
        defaultHelpText.AppendLine();

        var initializeLookupBuilder = new StringBuilder();

        foreach (var request in userRequests)
        {
            var userCommandAttribute = GetUserCommandAttributeValue(request);
            var commandHelp = userCommandAttribute?.HelpText;
            if (!userCommandAttribute.HasValue || commandHelp is null)
            {
                continue;
            }

            defaultHelpText.AppendLine(userCommandAttribute.Value.UserCommand);

            var helpTextBuilder = new StringBuilder();
            helpTextBuilder.AppendLine(commandHelp);

            foreach (var member in request.GetMembers().Where(x => x.Kind == SymbolKind.Property))
            {
                var propertySymbol = (IPropertySymbol)member;
                var argAttributeData = GetUserCommandArgumentAttributeValue(propertySymbol);

                if (argAttributeData is null)
                {
                    continue;
                }

                var (longName, shortName, helpText, isRequired, isHidden) = argAttributeData.Value;

                if (isHidden)
                {
                    continue;
                }

                helpTextBuilder.AppendLine();
                helpTextBuilder.Append(longName ?? propertySymbol.Name);
                if (isRequired)
                {
                    helpTextBuilder.Append(" (required)");
                }

                helpTextBuilder.AppendLine();

                if (!string.IsNullOrWhiteSpace(helpText))
                {
                    helpTextBuilder.AppendLine("\t" + helpText);
                }
            }

            initializeLookupBuilder.AppendLine($"        {Lookup}[{request.Name}.CommandKey[1..]] = @\"{helpTextBuilder}\";");
        }

        codeBuilder.AppendLine(@"
namespace Moneo.Chat;

public static class HelpResponseFactory
{
    private static readonly Dictionary<string, string> _lookup = new(StringComparer.OrdinalIgnoreCase);
    
    public static readonly string DefaultHelpResponse = @""");
        codeBuilder.Append(defaultHelpText.ToString());
        codeBuilder.AppendLine("\";");
        codeBuilder.AppendLine(@"

    public static string? GetHelpResponse(string commandKey)
    {
        if (_lookup.Count == 0)
        {
            InitializeLookup();
        }

        if (!_lookup.TryGetValue(commandKey, out var response))
        {
            return null;
        }

        return response;
    }

    private static void InitializeLookup()
    {");
        codeBuilder.Append(initializeLookupBuilder.ToString());
        codeBuilder.AppendLine(@"   }
}");

        return codeBuilder.ToString();
    }

    private static (string? LongName, string? ShortName, string? HelpText, bool IsRequired, bool IsHidden)?
        GetUserCommandArgumentAttributeValue(ISymbol symbol)
    {
        var attribute = symbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == AttributeKeys.UserCommandArgumentAttribute);

        if (attribute is null)
        {
            return null;
        }

        var longNameArg = attribute.NamedArguments.FirstOrDefault(arg => arg.Key == "LongName");
        var shortNameArg = attribute.NamedArguments.FirstOrDefault(arg => arg.Key == "ShortName");
        var helpTextArg = attribute.NamedArguments.FirstOrDefault(arg => arg.Key == "HelpText");
        var isRequiredArg = attribute.NamedArguments.FirstOrDefault(arg => arg.Key == "IsRequired");
        var isHiddenArg = attribute.NamedArguments.FirstOrDefault(arg => arg.Key == "IsHidden");

        if (longNameArg.Key != null)
        {
            return (longNameArg.Value.Value?.ToString(), shortNameArg.Value.Value?.ToString(),
                helpTextArg.Value.Value?.ToString(), (bool) (isRequiredArg.Value.Value ?? false),
                (bool) (isHiddenArg.Value.Value ?? false));
        }

        return null;
    }

    private static (string? UserCommand, string? HelpText)? GetUserCommandAttributeValue(ISymbol symbol)
    {
        var f = symbol.GetAttributes();
        var attribute = symbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == AttributeKeys.UserCommandAttribute);

        if (attribute is null)
        {
            return null;
        }
        
        var commandKeyArg = attribute.NamedArguments.FirstOrDefault(arg => arg.Key.Equals(AttributeKeys.CommandKey, StringComparison.OrdinalIgnoreCase));
        var helpTextArg = attribute.NamedArguments.FirstOrDefault(arg => arg.Key.Equals(AttributeKeys.UserCommandHelpText, StringComparison.OrdinalIgnoreCase));

        if (commandKeyArg.Key != null)
        {
            return (commandKeyArg.Value.Value?.ToString(), helpTextArg.Value.Value?.ToString());
        }

        return null;
    }

    private static string GenerateCommandKeyProperties(ISymbol userRequest)
    {
        var commandKeyValue = GetUserCommandAttributeValue(userRequest);

        if (commandKeyValue is null)
        {
            throw new InvalidOperationException($"{userRequest.Name} must be marked with a UserCommandAttribute");
        }
        
        var builder = new StringBuilder("// Generated By Source Generator\n\n");
        builder.AppendLine($"\nnamespace {userRequest.ContainingNamespace.ToDisplayString()};");
        builder.AppendLine("\n");
        builder.AppendLine($"public partial class {userRequest.Name}");
        builder.AppendLine("{");
        builder.AppendLine($"    public const string {AttributeKeys.CommandKey} = \"{commandKeyValue.Value.UserCommand}\";");
        builder.AppendLine("}");
        return builder.ToString();
    }

    private static string GenerateFactoryClass(ImmutableArray<INamedTypeSymbol> userRequests)
    {
        var namespaces = userRequests.Select(u => u.ContainingNamespace.ToDisplayString()).ToImmutableHashSet();

        var codeBuilder = new StringBuilder("// Generated By Source Generator\n\n");

        foreach (var ns in namespaces.OrderBy(k => k))
        {
            codeBuilder.Append("using ");
            codeBuilder.Append(ns);
            codeBuilder.AppendLine(";");
        }
        
        codeBuilder.AppendLine(@"
namespace Moneo.Chat;

public static class UserRequestFactory
{
    private static readonly Dictionary<string, Func<long, string[], IUserRequest>> _lookup = new(StringComparer.OrdinalIgnoreCase);

    public static IUserRequest? GetUserRequest(CommandContext context)
    {
        if (_lookup.Count == 0)
        {
            InitializeLookup();
        }

        if (!_lookup.TryGetValue(context.CommandKey, out var constructor))
        {
            return null;
        }

        return constructor.Invoke(context.ConversationId, context.Args);
    }

    private static void InitializeLookup()
    {");

        foreach (var request in userRequests)
        {
            codeBuilder.AppendLine($"        {Lookup}[{request.Name}.CommandKey] = (id, args) => new {request.Name}(id, args);");
        }

        codeBuilder.AppendLine(@"   }
}");

        return codeBuilder.ToString();
    }

    private static ImmutableArray<INamedTypeSymbol> GetUserRequests(
        GeneratorExecutionContext context)
    {
        var requests = new List<INamedTypeSymbol>();
        foreach (var syntaxTree in context.Compilation.SyntaxTrees)
        {
            var model = context.Compilation.GetSemanticModel(syntaxTree);
            var classes = syntaxTree.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>();
            var userRequests = classes
                .Select(c => model.GetDeclaredSymbol(c))
                .OfType<INamedTypeSymbol>()
                .Where(t => t.AllInterfaces.Select(i => i.Name).Contains("IUserRequest") && !t.IsAbstract);
            
            requests.AddRange(userRequests);
        }

        return requests.ToImmutableArray();
    }
}